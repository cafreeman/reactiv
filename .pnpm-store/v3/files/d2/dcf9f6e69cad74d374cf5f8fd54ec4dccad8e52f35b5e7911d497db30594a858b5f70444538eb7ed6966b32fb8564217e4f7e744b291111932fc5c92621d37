var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _LruCacheImpl_max, _LruCacheImpl_lruCache, _CommittingTransactionImpl_mergedRevisions, _LiveCacheTransactionImpl_originalCacheReference, _LiveCacheTransactionImpl_transactionalCache, _LiveCacheTransactionImpl_localUpdatedEntries, _LiveCacheTransactionImpl_commitingTransaction, _LiveCacheTransactionImpl_cacheSnapshotBeforeCommit, _LiveCacheTransactionImpl_cacheEntryState, _LiveCacheTransactionImpl_userOptionRetentionPolicy, _LiveCacheTransactionImpl_ttlPolicy, _LiveCacheTransactionImpl_lruPolicy, _LiveCacheTransactionImpl_localRevisions, _LiveCacheTransactionImpl_entryRevisions, _CacheImpl_weakCache, _CacheImpl_entryRevisions, _CacheImpl_cacheOptions, _CacheImpl_cacheEntryState, _CacheImpl_lruCache, _CacheImpl_lruPolicy;
// eslint-disable-next-line
function structuredClone(x) {
    try {
        return JSON.parse(JSON.stringify(x));
    }
    catch (error) {
        throw new Error('The cache value is not structured clonable use `save` with serializer');
    }
}
const DEFAULT_EXPIRATION = { lru: 1000, ttl: 60000 };
const DEFAULT_ENTRY_STATE = {
    retained: { lru: false, ttl: DEFAULT_EXPIRATION.ttl },
};
class LruCacheImpl {
    constructor(maxCapacity) {
        _LruCacheImpl_max.set(this, void 0);
        _LruCacheImpl_lruCache.set(this, void 0);
        __classPrivateFieldSet(this, _LruCacheImpl_max, maxCapacity, "f");
        __classPrivateFieldSet(this, _LruCacheImpl_lruCache, new Map(), "f");
    }
    set(cacheKey, value) {
        // refresh data
        if (__classPrivateFieldGet(this, _LruCacheImpl_lruCache, "f").has(cacheKey)) {
            __classPrivateFieldGet(this, _LruCacheImpl_lruCache, "f").delete(cacheKey);
        }
        else if (__classPrivateFieldGet(this, _LruCacheImpl_lruCache, "f").size === __classPrivateFieldGet(this, _LruCacheImpl_max, "f")) {
            // find and evict the LRU entry
            const lruEntryKey = __classPrivateFieldGet(this, _LruCacheImpl_lruCache, "f").keys().next().value;
            __classPrivateFieldGet(this, _LruCacheImpl_lruCache, "f").delete(lruEntryKey);
        }
        __classPrivateFieldGet(this, _LruCacheImpl_lruCache, "f").set(cacheKey, value);
    }
    getCache() {
        return __classPrivateFieldGet(this, _LruCacheImpl_lruCache, "f");
    }
}
_LruCacheImpl_max = new WeakMap(), _LruCacheImpl_lruCache = new WeakMap();
class CommittingTransactionImpl {
    constructor() {
        _CommittingTransactionImpl_mergedRevisions.set(this, void 0);
        this.cache = {
            clearRevisions(tx, id) {
                __classPrivateFieldGet(tx, _CommittingTransactionImpl_mergedRevisions, "f").delete(id);
            },
            appendRevisions(tx, id, revisions) {
                if (__classPrivateFieldGet(tx, _CommittingTransactionImpl_mergedRevisions, "f").has(id)) {
                    const appendedRevisions = __classPrivateFieldGet(tx, _CommittingTransactionImpl_mergedRevisions, "f").get(id)?.concat(revisions) || [];
                    __classPrivateFieldGet(tx, _CommittingTransactionImpl_mergedRevisions, "f").set(id, appendedRevisions);
                }
                else {
                    __classPrivateFieldGet(tx, _CommittingTransactionImpl_mergedRevisions, "f").set(id, revisions);
                }
            },
        };
        __classPrivateFieldSet(this, _CommittingTransactionImpl_mergedRevisions, new Map(), "f");
    }
    [(_CommittingTransactionImpl_mergedRevisions = new WeakMap(), Symbol.asyncIterator)](entryMap) {
        throw new Error('Method not implemented.');
    }
    mergedRevisions() {
        return __classPrivateFieldGet(this, _CommittingTransactionImpl_mergedRevisions, "f");
    }
}
class LiveCacheTransactionImpl {
    constructor(originalCache, transactionalCacheEntryMap, entryRevisions) {
        _LiveCacheTransactionImpl_originalCacheReference.set(this, void 0);
        _LiveCacheTransactionImpl_transactionalCache.set(this, void 0);
        _LiveCacheTransactionImpl_localUpdatedEntries.set(this, void 0);
        _LiveCacheTransactionImpl_commitingTransaction.set(this, void 0);
        _LiveCacheTransactionImpl_cacheSnapshotBeforeCommit.set(this, void 0);
        _LiveCacheTransactionImpl_cacheEntryState.set(this, void 0);
        _LiveCacheTransactionImpl_userOptionRetentionPolicy.set(this, void 0);
        _LiveCacheTransactionImpl_ttlPolicy.set(this, void 0);
        _LiveCacheTransactionImpl_lruPolicy.set(this, void 0);
        _LiveCacheTransactionImpl_localRevisions.set(this, void 0);
        _LiveCacheTransactionImpl_entryRevisions.set(this, void 0);
        __classPrivateFieldSet(this, _LiveCacheTransactionImpl_originalCacheReference, originalCache, "f");
        __classPrivateFieldSet(this, _LiveCacheTransactionImpl_transactionalCache, transactionalCacheEntryMap, "f");
        __classPrivateFieldSet(this, _LiveCacheTransactionImpl_localUpdatedEntries, new Map(), "f");
        __classPrivateFieldSet(this, _LiveCacheTransactionImpl_cacheSnapshotBeforeCommit, new Map(), "f");
        __classPrivateFieldSet(this, _LiveCacheTransactionImpl_cacheEntryState, new Map(), "f");
        __classPrivateFieldSet(this, _LiveCacheTransactionImpl_ttlPolicy, DEFAULT_EXPIRATION.ttl, "f");
        __classPrivateFieldSet(this, _LiveCacheTransactionImpl_lruPolicy, DEFAULT_EXPIRATION.lru, "f");
        __classPrivateFieldSet(this, _LiveCacheTransactionImpl_localRevisions, new Map(), "f");
        __classPrivateFieldSet(this, _LiveCacheTransactionImpl_entryRevisions, entryRevisions, "f");
        __classPrivateFieldSet(this, _LiveCacheTransactionImpl_userOptionRetentionPolicy, __classPrivateFieldGet(this, _LiveCacheTransactionImpl_originalCacheReference, "f").getCacheOptions()?.expiration ||
            DEFAULT_EXPIRATION, "f");
        if (__classPrivateFieldGet(this, _LiveCacheTransactionImpl_userOptionRetentionPolicy, "f") &&
            __classPrivateFieldGet(this, _LiveCacheTransactionImpl_userOptionRetentionPolicy, "f")?.lru &&
            typeof __classPrivateFieldGet(this, _LiveCacheTransactionImpl_userOptionRetentionPolicy, "f").lru === 'number') {
            __classPrivateFieldSet(this, _LiveCacheTransactionImpl_lruPolicy, __classPrivateFieldGet(this, _LiveCacheTransactionImpl_userOptionRetentionPolicy, "f").lru, "f");
        }
        if (__classPrivateFieldGet(this, _LiveCacheTransactionImpl_userOptionRetentionPolicy, "f") &&
            __classPrivateFieldGet(this, _LiveCacheTransactionImpl_userOptionRetentionPolicy, "f")?.ttl &&
            typeof __classPrivateFieldGet(this, _LiveCacheTransactionImpl_userOptionRetentionPolicy, "f").ttl === 'number') {
            __classPrivateFieldSet(this, _LiveCacheTransactionImpl_ttlPolicy, __classPrivateFieldGet(this, _LiveCacheTransactionImpl_userOptionRetentionPolicy, "f").ttl, "f");
        }
        __classPrivateFieldSet(this, _LiveCacheTransactionImpl_commitingTransaction, new CommittingTransactionImpl(), "f");
    }
    static async beginLiveTransaction(originalCache) {
        const transactionalCache = new Map();
        const entryRevisions = new Map();
        for await (const [key, value] of originalCache.entries()) {
            transactionalCache.set(key, { ...value });
            for await (const entryRevision of originalCache.entryRevisions(key)) {
                entryRevisions.set(key, [entryRevision]);
            }
        }
        return new LiveCacheTransactionImpl(originalCache, transactionalCache, entryRevisions);
    }
    get(cacheKey) {
        const cacheValue = __classPrivateFieldGet(this, _LiveCacheTransactionImpl_transactionalCache, "f").get(cacheKey);
        if (cacheValue) {
            // Update cache entry state
            __classPrivateFieldGet(this, _LiveCacheTransactionImpl_cacheEntryState, "f").set(cacheKey, {
                retained: { lru: true, ttl: __classPrivateFieldGet(this, _LiveCacheTransactionImpl_ttlPolicy, "f") },
                lastAccessed: Date.now(),
            });
        }
        return cacheValue;
    }
    async *[(_LiveCacheTransactionImpl_originalCacheReference = new WeakMap(), _LiveCacheTransactionImpl_transactionalCache = new WeakMap(), _LiveCacheTransactionImpl_localUpdatedEntries = new WeakMap(), _LiveCacheTransactionImpl_commitingTransaction = new WeakMap(), _LiveCacheTransactionImpl_cacheSnapshotBeforeCommit = new WeakMap(), _LiveCacheTransactionImpl_cacheEntryState = new WeakMap(), _LiveCacheTransactionImpl_userOptionRetentionPolicy = new WeakMap(), _LiveCacheTransactionImpl_ttlPolicy = new WeakMap(), _LiveCacheTransactionImpl_lruPolicy = new WeakMap(), _LiveCacheTransactionImpl_localRevisions = new WeakMap(), _LiveCacheTransactionImpl_entryRevisions = new WeakMap(), Symbol.asyncIterator)](entryMap) {
        for (const [key, value] of entryMap) {
            const state = __classPrivateFieldGet(this, _LiveCacheTransactionImpl_cacheEntryState, "f").get(key) || DEFAULT_ENTRY_STATE;
            yield [key, value, state];
        }
    }
    entries() {
        return this[Symbol.asyncIterator](__classPrivateFieldGet(this, _LiveCacheTransactionImpl_transactionalCache, "f"));
    }
    localEntries() {
        return this[Symbol.asyncIterator](__classPrivateFieldGet(this, _LiveCacheTransactionImpl_localUpdatedEntries, "f"));
    }
    localRevisions(cacheKey) {
        const entryRevisionIterator = {
            async *[Symbol.asyncIterator](revisions) {
                for (const revision of revisions) {
                    yield revision;
                }
            },
        };
        const revisions = __classPrivateFieldGet(this, _LiveCacheTransactionImpl_localRevisions, "f").get(cacheKey) || [];
        return entryRevisionIterator[Symbol.asyncIterator](revisions);
    }
    entryRevisions(cacheKey) {
        const entryRevisionIterator = {
            async *[Symbol.asyncIterator](revisions) {
                for (const revision of revisions) {
                    yield revision;
                }
            },
        };
        const entryRevisions = __classPrivateFieldGet(this, _LiveCacheTransactionImpl_entryRevisions, "f").get(cacheKey) || [];
        const localRevisions = __classPrivateFieldGet(this, _LiveCacheTransactionImpl_localRevisions, "f").get(cacheKey) || [];
        return entryRevisionIterator[Symbol.asyncIterator](entryRevisions.concat(localRevisions));
    }
    set(cacheKey, value) {
        __classPrivateFieldGet(this, _LiveCacheTransactionImpl_transactionalCache, "f").set(cacheKey, value);
        __classPrivateFieldGet(this, _LiveCacheTransactionImpl_localUpdatedEntries, "f").set(cacheKey, value);
        // Update cache entry state
        __classPrivateFieldGet(this, _LiveCacheTransactionImpl_cacheEntryState, "f").set(cacheKey, {
            retained: { lru: true, ttl: __classPrivateFieldGet(this, _LiveCacheTransactionImpl_ttlPolicy, "f") },
            lastAccessed: Date.now(),
        });
        return value;
    }
    async delete(cacheKey) {
        return new Promise((resolve) => {
            if (__classPrivateFieldGet(this, _LiveCacheTransactionImpl_transactionalCache, "f").has(cacheKey)) {
                __classPrivateFieldGet(this, _LiveCacheTransactionImpl_transactionalCache, "f").delete(cacheKey);
            }
            if (__classPrivateFieldGet(this, _LiveCacheTransactionImpl_localUpdatedEntries, "f").has(cacheKey)) {
                __classPrivateFieldGet(this, _LiveCacheTransactionImpl_localUpdatedEntries, "f").delete(cacheKey);
            }
            return resolve(__classPrivateFieldGet(this, _LiveCacheTransactionImpl_transactionalCache, "f").has(cacheKey) === false &&
                __classPrivateFieldGet(this, _LiveCacheTransactionImpl_localUpdatedEntries, "f").has(cacheKey) === false);
        });
    }
    async merge(cacheKey, entityRevision, options) {
        // assign custom merge strategy if specified else use default
        const mergeStrategyFromCacheOptionHook = __classPrivateFieldGet(this, _LiveCacheTransactionImpl_originalCacheReference, "f").getCacheOptions()?.hooks
            ?.entitymergeStrategy;
        const mergeStrategy = mergeStrategyFromCacheOptionHook || defaultMergeStrategy;
        // get current cache value within this transaction
        const currentValue = __classPrivateFieldGet(this, _LiveCacheTransactionImpl_transactionalCache, "f").get(cacheKey);
        const mergedEntity = mergeStrategy(cacheKey, {
            entity: entityRevision.entity,
            revision: entityRevision.revision,
            revisionContext: entityRevision?.revisionContext,
        }, currentValue, this);
        // TODO throw error if Merge entity is undefined
        // Update transactional cache with merged entity
        this.set(cacheKey, mergedEntity);
        // Update local & entry revisions with new revision values
        const revision = {
            entity: mergedEntity,
            revision: entityRevision.revision,
            revisionContext: entityRevision?.revisionContext,
        };
        if (__classPrivateFieldGet(this, _LiveCacheTransactionImpl_localRevisions, "f").has(cacheKey)) {
            __classPrivateFieldGet(this, _LiveCacheTransactionImpl_localRevisions, "f").get(cacheKey)?.push(revision);
        }
        else {
            __classPrivateFieldGet(this, _LiveCacheTransactionImpl_localRevisions, "f").set(cacheKey, [revision]);
        }
        return mergedEntity;
    }
    async commit(options) {
        for await (const [cacheKey] of __classPrivateFieldGet(this, _LiveCacheTransactionImpl_originalCacheReference, "f").entries()) {
            const originalCacheValue = await __classPrivateFieldGet(this, _LiveCacheTransactionImpl_originalCacheReference, "f").get(cacheKey);
            if (originalCacheValue) {
                __classPrivateFieldGet(this, _LiveCacheTransactionImpl_cacheSnapshotBeforeCommit, "f").set(cacheKey, {
                    ...originalCacheValue,
                });
            }
        }
        const timeout = options?.timeout ? options.timeout : 10000;
        const commitLock = new Promise((resolve, reject) => setTimeout(reject, timeout));
        const writeToCache = async () => {
            const trasactionCacheEntries = [];
            for await (const [cacheKey, value, state] of this.localEntries()) {
                const latestCacheValue = await __classPrivateFieldGet(this, _LiveCacheTransactionImpl_originalCacheReference, "f").get(cacheKey);
                let entityToCommit;
                // assign custom merge strategy if specified else use default
                const mergeStrategyFromCacheOptionHook = __classPrivateFieldGet(this, _LiveCacheTransactionImpl_originalCacheReference, "f").getCacheOptions()?.hooks
                    ?.entitymergeStrategy;
                const mergeStrategy = mergeStrategyFromCacheOptionHook || defaultMergeStrategy;
                if (latestCacheValue) {
                    // TODO fix revision
                    entityToCommit = mergeStrategy(cacheKey, { entity: value, revision: 3 }, latestCacheValue, this);
                }
                else {
                    entityToCommit = value;
                }
                const structuredClonedValue = structuredClone(entityToCommit);
                trasactionCacheEntries.push([cacheKey, structuredClonedValue, state]);
                // Update saved revisions of the entity
                const localRevisions = __classPrivateFieldGet(this, _LiveCacheTransactionImpl_localRevisions, "f").get(cacheKey);
                let revisionNumber = localRevisions && localRevisions[localRevisions.length - 1].revision
                    ? localRevisions[localRevisions.length - 1].revision
                    : 0;
                const entityRevision = {
                    entity: entityToCommit,
                    revision: ++revisionNumber,
                };
                if (__classPrivateFieldGet(this, _LiveCacheTransactionImpl_localRevisions, "f").has(cacheKey)) {
                    __classPrivateFieldGet(this, _LiveCacheTransactionImpl_localRevisions, "f").get(cacheKey)?.push(entityRevision);
                }
                else {
                    __classPrivateFieldGet(this, _LiveCacheTransactionImpl_localRevisions, "f").set(cacheKey, [entityRevision]);
                }
                const revisionStrategy = __classPrivateFieldGet(this, _LiveCacheTransactionImpl_originalCacheReference, "f").getCacheOptions()
                    ?.hooks?.revisionMergeStrategy
                    ? async (id, commitTx, liveTx) => __classPrivateFieldGet(this, _LiveCacheTransactionImpl_originalCacheReference, "f").getCacheOptions()?.hooks
                        ?.revisionMergeStrategy
                    : defaultRevisionStrategy;
                // Update revisions based on revision strategy
                await revisionStrategy(cacheKey, __classPrivateFieldGet(this, _LiveCacheTransactionImpl_commitingTransaction, "f"), this);
            }
            // Call commit hook to apply custom retention policies before commit (if passed by cache options)
            const customRetentionPolicy = __classPrivateFieldGet(this, _LiveCacheTransactionImpl_originalCacheReference, "f").getCacheOptions()?.hooks?.commit;
            if (customRetentionPolicy) {
                customRetentionPolicy(this);
            }
            const mergedRevisions = __classPrivateFieldGet(this, _LiveCacheTransactionImpl_commitingTransaction, "f").mergedRevisions();
            // commit merged transaction & revisions entries to main cache
            await __classPrivateFieldGet(this, _LiveCacheTransactionImpl_originalCacheReference, "f").commitTransaction(trasactionCacheEntries, mergedRevisions);
        };
        try {
            await Promise.race([writeToCache(), commitLock]);
        }
        catch {
            // TODO throw error/warning
            await this.rollback();
        }
    }
    async rollback() {
        const arrayOfCacheEntryTuples = [];
        for (const [cacheKey] of __classPrivateFieldGet(this, _LiveCacheTransactionImpl_cacheSnapshotBeforeCommit, "f")) {
            const prevCacheValue = __classPrivateFieldGet(this, _LiveCacheTransactionImpl_cacheSnapshotBeforeCommit, "f").get(cacheKey);
            const structuredClonedValue = structuredClone(prevCacheValue);
            arrayOfCacheEntryTuples.push([cacheKey, structuredClonedValue]);
        }
        await __classPrivateFieldGet(this, _LiveCacheTransactionImpl_originalCacheReference, "f").clear();
        await __classPrivateFieldGet(this, _LiveCacheTransactionImpl_originalCacheReference, "f").load(arrayOfCacheEntryTuples);
    }
}
class CacheImpl {
    constructor(options) {
        _CacheImpl_weakCache.set(this, void 0);
        _CacheImpl_entryRevisions.set(this, void 0);
        _CacheImpl_cacheOptions.set(this, void 0);
        _CacheImpl_cacheEntryState.set(this, void 0);
        _CacheImpl_lruCache.set(this, void 0);
        _CacheImpl_lruPolicy.set(this, void 0);
        __classPrivateFieldSet(this, _CacheImpl_weakCache, new Map(), "f");
        __classPrivateFieldSet(this, _CacheImpl_cacheOptions, options, "f");
        __classPrivateFieldSet(this, _CacheImpl_lruPolicy, DEFAULT_EXPIRATION.lru, "f");
        __classPrivateFieldSet(this, _CacheImpl_entryRevisions, new Map(), "f");
        __classPrivateFieldSet(this, _CacheImpl_cacheEntryState, new Map(), "f");
        const expiration = __classPrivateFieldGet(this, _CacheImpl_cacheOptions, "f")?.expiration || DEFAULT_EXPIRATION;
        if (expiration && expiration?.lru && typeof expiration.lru === 'number') {
            __classPrivateFieldSet(this, _CacheImpl_lruPolicy, expiration.lru, "f");
        }
        __classPrivateFieldSet(this, _CacheImpl_lruCache, new LruCacheImpl(__classPrivateFieldGet(this, _CacheImpl_lruPolicy, "f")), "f");
    }
    /**
      Evict all entries from the cache.
    */
    async clear() {
        for await (const [key] of this.entries()) {
            __classPrivateFieldGet(this, _CacheImpl_weakCache, "f").delete(key);
            __classPrivateFieldGet(this, _CacheImpl_lruCache, "f").getCache().delete(key);
            __classPrivateFieldGet(this, _CacheImpl_entryRevisions, "f").delete(key);
        }
    }
    getCacheOptions() {
        return __classPrivateFieldGet(this, _CacheImpl_cacheOptions, "f");
    }
    async get(cacheKey) {
        let ref = __classPrivateFieldGet(this, _CacheImpl_weakCache, "f").get(cacheKey);
        return ref?.deref();
    }
    /**
      Calling `.save()` without a serializer will iterate over the cache entries
      and return an array of cache entry tuples.
    */
    async save() {
        const arrayOfCacheEntryTuples = [];
        for await (const [key, value, state] of this.entries()) {
            // TODO create state?
            const structuredClonedValue = structuredClone(value);
            arrayOfCacheEntryTuples.push([key, structuredClonedValue, state]);
        }
        return arrayOfCacheEntryTuples;
    }
    /**
      Calling `.load()` will add all entries passed to the cache.
      Note: `.load()` does not clear pre-existing entries, if you need to clear
      entries before loading call `.clear()`.
    */
    async load(entries) {
        let revisionCounter = 0;
        for await (let entry of entries) {
            let [key, value, state] = entry;
            // TODO: finalizregistry
            let clone = structuredClone(value);
            __classPrivateFieldGet(this, _CacheImpl_weakCache, "f").set(key, new WeakRef(clone));
            __classPrivateFieldGet(this, _CacheImpl_lruCache, "f").set(key, clone);
            __classPrivateFieldGet(this, _CacheImpl_cacheEntryState, "f").set(key, state);
            const entityRevision = {
                entity: value,
                revision: ++revisionCounter,
            };
            if (__classPrivateFieldGet(this, _CacheImpl_entryRevisions, "f").has(key)) {
                const revisions = __classPrivateFieldGet(this, _CacheImpl_entryRevisions, "f").get(key)?.concat(entityRevision) || [];
                __classPrivateFieldGet(this, _CacheImpl_entryRevisions, "f").set(key, revisions);
            }
            else {
                __classPrivateFieldGet(this, _CacheImpl_entryRevisions, "f").set(key, [entityRevision]);
            }
        }
    }
    async commitTransaction(entries, entryRevisions) {
        const sortEntries = entries.sort(([, , state], [, , state1]) => state?.lastAccessed &&
            state1?.lastAccessed &&
            state?.lastAccessed < state1?.lastAccessed
            ? 1
            : -1);
        for await (let entry of sortEntries) {
            let [key, value, state] = entry;
            // TODO: finalizregistry
            __classPrivateFieldGet(this, _CacheImpl_weakCache, "f").set(key, new WeakRef(value));
            __classPrivateFieldGet(this, _CacheImpl_cacheEntryState, "f").set(key, state);
            if (state?.retained.lru) {
                __classPrivateFieldGet(this, _CacheImpl_lruCache, "f").set(key, value);
            }
        }
        for await (const [cacheKey, revision] of entryRevisions) {
            if (__classPrivateFieldGet(this, _CacheImpl_entryRevisions, "f").has(cacheKey)) {
                const revisions = __classPrivateFieldGet(this, _CacheImpl_entryRevisions, "f").get(cacheKey)?.concat(revision) || [];
                __classPrivateFieldGet(this, _CacheImpl_entryRevisions, "f").set(cacheKey, revisions);
            }
            else {
                __classPrivateFieldGet(this, _CacheImpl_entryRevisions, "f").set(cacheKey, revision);
            }
        }
    }
    /**
      Generator function for async iterable that yields iterable cache entries. This
      will include both strongly held (unexpired entries) as well as weakly held
      entries.
    */
    async *[(_CacheImpl_weakCache = new WeakMap(), _CacheImpl_entryRevisions = new WeakMap(), _CacheImpl_cacheOptions = new WeakMap(), _CacheImpl_cacheEntryState = new WeakMap(), _CacheImpl_lruCache = new WeakMap(), _CacheImpl_lruPolicy = new WeakMap(), Symbol.asyncIterator)]() {
        // yield weekly held values
        for await (const [key] of __classPrivateFieldGet(this, _CacheImpl_weakCache, "f")) {
            const valueRef = __classPrivateFieldGet(this, _CacheImpl_weakCache, "f").get(key)?.deref();
            // Because of the limited guarantees of `FinalizationRegistry`, when yielding
            // weakly-held values to the user in `entries` we have to check that the
            // value is actually present,
            if (!valueRef) {
                throw new Error('ref is undefined');
            }
            const state = __classPrivateFieldGet(this, _CacheImpl_cacheEntryState, "f").get(key) || DEFAULT_ENTRY_STATE;
            yield [key, valueRef, state];
        }
    }
    /**
      Generator function that yields each of the iterable cache entries. Note that this
      will include both strongly held (unexpired entries) as well as weakly held
      entries.
    */
    entries() {
        return this[Symbol.asyncIterator]();
    }
    entryRevisions(cacheKey) {
        const entryRevisionIterator = {
            async *[Symbol.asyncIterator](revisions) {
                for (const revision of revisions) {
                    yield revision;
                }
            },
        };
        const revisions = __classPrivateFieldGet(this, _CacheImpl_entryRevisions, "f").get(cacheKey) || [];
        return entryRevisionIterator[Symbol.asyncIterator](revisions);
    }
    /**
     * Generator function that yields each of the iterable cache entry Keys.
     */
    async *keys() {
        for await (const [key] of this.entries()) {
            yield key;
        }
    }
    /**
     * Generator function that yields each of the iterable cache entry Values.
     */
    async *values() {
        for await (const [, value] of this.entries()) {
            yield value;
        }
    }
    async beginTransaction() {
        return await LiveCacheTransactionImpl.beginLiveTransaction(this);
    }
}
export function buildCache(options) {
    return new CacheImpl(options);
}
const defaultMergeStrategy = function deepMergeStratey(id, { entity, revision }, current, tx) {
    return deepMerge(current, entity);
};
const defaultRevisionStrategy = async function retainAllRevisions(id, commitTx, liveTx) {
    const revisions = [];
    for await (const revision of liveTx.localRevisions(id)) {
        revisions.push(revision);
    }
    commitTx.cache.appendRevisions(commitTx, id, [...revisions]);
};
// eslint-disable-next-line
const isObject = function isObject(obj) {
    return obj !== null && !Array.isArray(obj) && typeof obj === 'object';
};
function deepMerge(targetData, sourceData) {
    const source = isObject(sourceData) ? { ...sourceData } : sourceData;
    const target = isObject(targetData) ? { ...targetData } : targetData;
    if (isObject(source) && isObject(target)) {
        Object.keys(source).forEach((sourceKey) => {
            if (Object.prototype.hasOwnProperty.call(target, sourceKey)) {
                if (source[sourceKey] != target[sourceKey]) {
                    // There is conflict that needs to be resolved
                    const result = resolveConflict(target, source, sourceKey);
                    if (result != target[sourceKey]) {
                        target[sourceKey] = result;
                    }
                }
            }
            else {
                // If there is no conflict, its safe, assign source to target
                target[sourceKey] = source[sourceKey];
            }
        });
        return target;
    }
    // If source or target is not an object use source.
    return source;
}
function resolveConflict(target, source, property) {
    return deepMerge(target[property], source[property]);
}
//# sourceMappingURL=cache.js.map